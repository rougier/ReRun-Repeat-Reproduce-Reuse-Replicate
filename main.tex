\documentclass[a4paper,11pt]{article}

% Wider margins (compared to default)
\usepackage[margin=2.5cm]{geometry}

% English support (typography and hyphenation)
\usepackage[english]{babel}

% Unicode encoding
\usepackage[utf8]{inputenc}

% Better default font (Libertine and Inconsolata)
\usepackage[ttscale=.875]{libertine}
\usepackage[scaled=0.96]{zi4}

% Biber
\usepackage[backend=biber, style=numeric, natbib=true]{biblatex}
\bibliography{library.bib}

% Graphics
\usepackage{graphicx}


% Code Listing
\usepackage[framemethod=tikz]{mdframed}
\usepackage{listings}
\surroundwithmdframed[
%  hidealllines=true,
  linewidth=0.25pt,
  linecolor=black!50,
  backgroundcolor=black!4,
  innerleftmargin=8pt,
  innertopmargin=3pt,
  innerbottommargin=3pt]{lstlisting}
\lstset{ %
  basicstyle=\small\tt\linespread{0.75},
  language=Python,
  commentstyle=\color{gray},
  columns=fullflexible,
}


% Hyperref
\usepackage{xcolor}
\definecolor{blendedblue}{rgb}{0.2, 0.2, 0.6}
\definecolor{blendedred}{rgb}{0.8, 0.2, 0.2}
\usepackage[bookmarks=true,
            breaklinks=true,
            pdfborder={0 0 0},
            citecolor=blendedblue,
            colorlinks=true,
            linkcolor=blendedblue,
            urlcolor=blendedblue,
            citecolor=blendedblue,
            linktocpage=false,
            hyperindex=true,
            linkbordercolor=white]{hyperref}
\usepackage{hyperref}
\hypersetup{colorlinks=true}



\title{The R Quintuplet (R$^5$)}
\author{Nicolas P. Rougier and Fabien C. Y. Benureau}
\date{\today}

\begin{document}
\maketitle

% -------------------------
\section*{Introduction (R$^{\mathbf 0}$)}

Scientific reproducibility and replicability issues have received increased attention in the past few years and computer science is no exception.
One could think that computer science would mostly be shielded from those issues. 
But precisely because it is easy to believe that if a program runs once (and gives expected results) it will do so forever, crucial steps to transform working code into meaningful scientific contributions are rarely undertaken; computer science is victim of reproducibility and replicability issues precisely because it seems impervious to them.

In fact, a program can fail in many different ways at many different levels for many different reasons.
Borrowing the terms coined by Ann Gobble, for your program to survive for some noticeable time, you have to make sure it is re-runnable, repeatable, reproducible, replicate and re-usable.\\

Let us illustrate this with a very simple example, a random walk written in Python:

\begin{lstlisting}
# A random walker (R0)
import numpy as np

# randomly choose ten instances of either 1 or -1. 
steps = np.random.choice([-1,+1], 10)
y = steps.cumsum() # compute the cumulative sum (the sum of all preceeding elements)
print y
\end{lstlisting}

Executed, this program would display 
\begin{lstlisting}
[-1  0 -1 -2 -1 -2 -3 -2 -1 -2] # with `steps` being [-1 1 -1 -1  1 -1 -1  1  1 -1]
\end{lstlisting}

What could go wrong with such a simple program?\\
\vfill
Well...
\vfill


% -------------------------
\clearpage
\section*{Re-runnable (R$^{\mathbf 1}$)}

Did you ever wonder if you would be able to run a program you wrote some time
ago? Let's consider a program you wrote yesterday. Most probably you can still
run it today, but would this still be true in a week, in a month, in a year or
in a decade? Probably you would legitimately answer positively for weeks
or even months if you're optimistic, but you may have doubts when considering
longer time periods such as years or even decades. Part of the problem is that
computer science is evolving at a very fast pace and you cannot know how the
system, the software and the libraries your program depends on will evolve.
If you want your program to have a tiny chance to be runnable ten years from
now, you better make it clear what are the dependencies in terms of systems,
software and libraries.\\
% TODO: cite Collberg 2014 study
\cite{Collberg:2016}

\begin{lstlisting}
# A random walker (R1)
# Tested with Python 3.6.0 / Numpy 1.12.0
import numpy as np

# Compute random walk for 10 steps
steps = 2*(np.random.uniform(-1, +1, 10) > 0) - 1
y = steps.cumsum()
print(y)
\end{lstlisting}

In our case, the R$^0$ version of our tiny walker uses the print {\em instruction} that is available in Python 2.x but has been deprecated in Python 3 in favor or a  print {\em function}.
This means this program cannot be run with Python 3 and needs to be fixed.
Since Python 2 will soon be discontinued, it may be best to target directly Python 3 and to use the print function (and as a matter of fact, it will work with Python 2).
Another potential problem is the numpy `choice` function that has been introduced only in numpy v1.7.
If for some reason, the installed version of numpy is older, the program will also fail.
One quick fix is to use a simpler way to generate the steps (even if it is less efficient).
Last and most important, we need to specify all the dependencies of our program.


\clearpage
\section*{Repeatable (R$^{\mathbf 2}$)}

After having taken care of specifying dependencies, you can legitimately hope to be able to run the program without too much trouble.
However this does not guarantee you will get the same results at each run.
For example, if you're using a (pseudo) random number generator, you have to take care of initializing the generator using a specific seed.
If not, you're doomed and you won't be able to get twice the same output. But still, there are actually many more pitfalls ahead.
For example, you can play with the seed value and find one that produce an interesting result that you will save in a file.
And the, you can continue to play with the seed in order get new results.
But what if you want to come back to one specific result?
How do you find the seed related to this specific output?
Again, if you did not foresee this potential problem, you're doomed.\\

Turning back to our random walker example, we can fix it quite easily by initializing the random number generator and produce a dictionary holding seed and result that allows us to reach the RÂ² level.

\begin{lstlisting}
# A random walker (R2)
# Tested with Python 3.6 / Numpy 1.12.0
import numpy as np

# Random generator initialization
seed = 1
np.random.seed(seed)

# Compute random walk for 10 steps
steps = np.random.choice([-1,+1], 10)
y = steps.cumsum()
print(y)
\end{lstlisting}


\clearpage
\section*{Reproducible (R$^{\mathbf 3}$)}

% Adding license for diffusion
% Lorena Barba example (Science blog)

\begin{lstlisting}
# A random walker (R3)
# Copyright (c) 2017 Nicolas P. Rougier and Fabien C.Y. Benureau
# Release under the BSD 2 clauses license
# Tested with Python 3.6 / Numpy 1.12.0 using macOS 10.12.4 on a 64 bits architecture
import numpy as np

def walk(n):
    """ Random walk for n steps """

    steps = 2*(np.random.uniform(-1,+1,n) > 0) - 1
    return steps.cumsum()

if __name__ == '__main__'
    # Unit test
    np.random.seed(1)
    assert walk(10) == [-1, 0, -1, -2, -3, -4, -5, -6, -7, -6]

    # Random generator initialization
    seed = 1
    np.random.seed(seed)
    
    # Compute random walk for n steps
    y = walk(n=10)

    # Save and display results
    results = {"seed": seed, "y": y}
    print(results["y"])
\end{lstlisting}


\clearpage
\section*{Replicable (R$^{\mathbf 4}$)}

There are some discrepancies between the numpy and the pure Python version due to subtle differences in the random generator.
As explained in the \href{https://docs.python.org/3.6/library/random.html}{Python documentation}, {\em Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats
and has a period of 2**19937-1.
The underlying implementation in C is both fast and threadsafe.}
But the numpy random generator is also based on the same Mersenne Twister generator and the difference comes from the way seed is interpreted to initialize the generator.
Fortunately, Python gives access to the internal state and we can {\em fix} it to make it match the behavior of the numpy generator (which is the default).

\begin{lstlisting}
# A random walker program (R4)
# A replication of the random walker using pure Python
# Copyright (c) 2017 Nicolas P. Rougier and Fabien C.Y. Benureau
# Release under the BSD 2 clauses license
# Tested with Python 3.6 using macOS 10.12.4 on a 64 bits architecture
import random
from itertools import accumulate

def state(seed):
    """ Compute the Mersenne Twister keys from given seed """
    mt = [seed] * (624+1)
    mt[-1] = 624
    for i in range(1, 624):
        mt[i] = int(0xFFFFFFFF & (1812433253 * (mt[i-1]^mt[i-1]>>30)+i))
    return (3, tuple(mt), None)

def walk(n=10):
    """ Random walk for n steps """

    steps = [-1 if random.uniform(-1,+1) < 0 else +1 for i in range(n)]
    return list(accumulate(steps))

if __name__ == '__main__'
    # Unit test
    random.setstate(state(seed=1))
    assert walk(n=10) == [-1, 0, -1, -2, -3, -4, -5, -6, -7, -6]

    # random generator initialization
    seed = 1
    random.setstate(state(seed))
    
    # Compute random walk for n steps
    y = walk(n=10)
    
    # Save and display results
    results = {"seed": seed, "y": y}
    print(results["y"])
\end{lstlisting}

\clearpage
\section*{Reusable (R$^{\mathbf 5}$)}

\clearpage
\section*{Conclusion}

% underscore that compared to psy/bio/etc. the replication issues of CS are easily (reasonably) managed: good solutions that (mostly) works exist right now.

\renewcommand*{\bibfont}{\small}
\printbibliography[title=References]


\end{document}

