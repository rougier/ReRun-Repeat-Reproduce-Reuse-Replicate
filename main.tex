\documentclass[a4paper,11pt]{article}

% Wider margins (compared to default)
\usepackage[margin=2.5cm]{geometry}

% English support (typography and hyphenation)
\usepackage[english]{babel}

% Unicode encoding
\usepackage[utf8]{inputenc}

% Better default font (Libertine and Inconsolata)
\usepackage[ttscale=.875]{libertine}
\usepackage[scaled=0.96]{zi4}

% Biber
\usepackage[backend=biber, style=numeric, natbib=true]{biblatex}
\bibliography{library.bib}

% Graphics
\usepackage{graphicx}


% Code Listing
\usepackage{listings}
\usepackage[framemethod=tikz]{mdframed}
\makeatletter
\def\mdf@@codeheading{Code Listings}
\define@key{mdf}{title}{\def\mdf@@codeheading{#1}}
\mdfdefinestyle{lstlisting}{%
  backgroundcolor=black!2.5,
  innertopmargin=2pt,
  middlelinewidth=0.75pt,
  outerlinewidth=9pt,
  outerlinecolor=white,
  innerleftmargin=10pt,
  innerrightmargin=10pt,
  leftmargin=0pt,
  rightmargin=0pt,
  rightline=false,
  leftline=false,
  bottomline=false,
  skipabove=\topskip,
  skipbelow=\topskip,
  roundcorner=0pt,
  singleextra={
    \node[text=black, % fill=white, draw,
          anchor=south west, yshift=-0.25pt, xshift=5pt,
          font=\sc\footnotesize] at (O|-P) {\csname mdf@@codeheading\endcsname};},
  firstextra={
    \node[text=black, % fill=white, draw,
          anchor=south west, yshift=-0.5pt, xshift=5pt,
          font=\sc\footnotesize] at (O|-P) {\csname mdf@@codeheading\endcsname};}
}

\lstset{ %
  basicstyle=\small\tt\linespread{0.75},
  language=Python,
  commentstyle=\color{gray},
  columns=fullflexible,
}

\lstnewenvironment{code}[2][]{%
  \lstset{#1}%
  \mdframed[style=lstlisting,title={#2}]%
}{\endmdframed}


%\usepackage{listings}
%\surroundwithmdframed[
%%  hidealllines=true,
%  linewidth=0.25pt,
%  linecolor=black!50,
%  backgroundcolor=black!4,
%  innerleftmargin=8pt,
%  innertopmargin=3pt,
%  innerbottommargin=3pt]{lstlisting}
%\lstset{ %
%  basicstyle=\small\tt\linespread{0.75},
%  language=Python,
%  commentstyle=\color{gray},
%  columns=fullflexible,
%}


% Hyperref
\usepackage{xcolor}
\definecolor{blendedblue}{rgb}{0.2, 0.2, 0.6}
\definecolor{blendedred}{rgb}{0.8, 0.2, 0.2}
\usepackage[bookmarks=true,
            breaklinks=true,
            pdfborder={0 0 0},
            citecolor=blendedblue,
            colorlinks=true,
            linkcolor=blendedblue,
            urlcolor=blendedblue,
            citecolor=blendedblue,
            linktocpage=false,
            hyperindex=true,
            linkbordercolor=white]{hyperref}
\usepackage{hyperref}
\hypersetup{colorlinks=true}



\title{The R Quintuplet (R$^5$)}
\author{Nicolas P. Rougier and Fabien C. Y. Benureau}
\date{\today}

\begin{document}
\maketitle


% -------------------------
\section*{Introduction (R$^{\mathbf 0}$)}

Scientific reproducibility and replicability issues have received increased attention in the past few years and computer science is no exception.
One could think that computer science would mostly be shielded from those issues. 
But precisely because it is easy to believe that if a program runs once (and gives expected results) it will do so forever, crucial steps to transform working code into meaningful scientific contributions are rarely undertaken; computer science is plagued by replication problems precisely because it seems impervious to them.\\

In fact, a program can fail in many different ways at many different levels for many different reasons.
Borrowing the terms coined by Carole Anne Gobble, for your program to survive for some noticeable time, you have to make sure it is re-runnable (R$^1$), repeatable (R$^2$), reproducible (R$^3$), replicable (R$^4$) and re-usable (R$^5$).\\

Let us illustrate this with a very simple example, a random walk written in Python:

\begin{code}{Random walk (R$^0$)}
# Random walk (R0: worst you can do)
import random

x = 0
for i in xrange(10):
    step = random.choice([-1,+1])
    x = x + step
    print x,
\end{code}
% That would be too easy if the program was commented...
% # randomly choose ten instances of either 1 or -1. 
% # compute the cumulative sum (the sum of all preceeding elements)

Executed, this program would display 
\begin{code}{Output}
[-1  0 -1 -2 -1 -2 -3 -2 -1 -2] # with `steps` being [-1 +1 -1 -1 +1 -1 -1 +1 +1 -1]
\end{code}

What could go wrong with such a simple program?\\
\vfill
Well...
\vfill


% -------------------------
\clearpage
\section*{Re-runnable (R$^{\mathbf 1}$)}

Have you ever try to re-run a program you wrote some years ago? Frustratingly, it is often surprisingly hard. 
Part of the problem is that computer science is evolving at a fast pace and you cannot know how the system, the software and the libraries your program depends on will evolve.
Since you wrote the code, you may have changed your computer or your operating system. The compiler, interpreter or set of libraries installed may have changed or been upgraded. 
You may find yourself battling with arcane issues of library compatibility---thoroughly orthogonal to your immediate research goals---to execute again a code \emph{that worked perfectly before}. 
% "thoroughly orthogonal to your immediate research goals": possibly problematic

To be clear, writing code that will run flawlessly months from now---without maintenance---is challenging. When considering years or decades, the best efforts can be stymied by the smallest changes, outside of the programmer's control. And modernizing a unmaintained ten-year-old code can reveal itself to be so complex and expensive that recreating the old execution environment is easier. For this however, the dependencies in terms of systems, software and libraries must be made clear enough.

A \emph{re-runnable} code is one that describes an execution environment in which it is executable and produce the expected results with enough details to be recreated.

% TODO: cite Collberg 2014 study
\cite{Collberg:2016}

\begin{code}{Random walk (R$^1$)}
# Random walk (R2: re-runnable)
# Tested with Python 3
import random
from itertools import accumulate

steps = random.choices([-1,+1], k=10)
x = list(accumulate(steps))
print(x) 
\end{code}

In our case, the R$^0$ version of our tiny walker seems to imply that any version of Python would be fine. This not the case for two reasons.

First, the R$^0$ version uses the print {\em instruction} that is available in Python 2 (this widly used, and installed by default in many operating systems) but has been deprecated in Python 3 (the current version, first released in 2008, almost a decade ago) in favor or a  print {\em function}.
This means that R$^0$ cannot be run with Python 3. 


Since Python 2 will soon be discontinued, it may be best to target directly Python 3 and to use the print function (and as a matter of fact, it will work with Python 2).
Another potential problem is the numpy `choice` function that has been introduced only in numpy v1.7.
If for some reason, the installed version of numpy is older, the program will also fail.
One quick fix is to use a simpler way to generate the steps (even if it is less efficient).
Last and most important, we need to specify all the dependencies of our program.


\clearpage
\section*{Repeatable (R$^{\mathbf 2}$)}

After having taken care of specifying dependencies, you can legitimately hope to be able to run the program without too much trouble.
However this does not guarantee you will get the same results at each run.
For example, if you're using a (pseudo) random number generator, you have to take care of initializing the generator using a specific seed.
If not, you're doomed and you won't be able to get twice the same output. But still, there are actually many more pitfalls ahead.
For example, you can play with the seed value and find one that produce an interesting result that you will save in a file.
And the, you can continue to play with the seed in order get new results.
But what if you want to come back to one specific result?
How do you find the seed related to this specific output?
Again, if you did not foresee this potential problem, you're doomed.\\

Turning back to our random walker example, we can fix it quite easily by initializing the random number generator and produce a dictionary holding seed and result that allows us to reach the RÂ² level.

\begin{code}{Random walk (R$^2$)}
# Random walk (R2: repeatable)
# Tested with Python 3
import random
from itertools import accumulate

# Random number generator initialization
random.seed(1)

# Compute random walk for 10 steps
steps = random.choices([-1,+1], k=10)
x = list(accumulate(steps))
print(x) 
\end{code}


\clearpage
\section*{Reproducible (R$^{\mathbf 3}$)}
As nicely explained by Mesnard and Barba \cite{Mesnard:2016}, reproducibility is harder than you may think.

% Adding license for diffusion
% Lorena Barba example (Science blog)

\begin{code}{Random walk (R$^3$)}
# Random walk (R3: reproducible)
# Copyright (c) 2017 Nicolas P. Rougier and Fabien C.Y. Benureau
# Release under the BSD 2-clause license
# Tested with Python 3.6 / macOS 10.12.4 / 64 bits architecture
import random
from itertools import accumulate

def walk(n):
    """ Random walk for n steps """

    steps = [-1 if random.uniform(-1,+1) < 0 else +1 for i in range(n)]
    return list(accumulate(steps))

if __name__ == '__main__':
    # Unit test
    random.seed(1)
    assert walk(10) == [-1, 0, 1, 0, -1, -2, -1, 0, -1, -2]

    # Actual results
    random.seed(2)
    print(walk(10))
\end{code}


\clearpage
\section*{Replicable (R$^{\mathbf 4}$)}

There are some discrepancies between the numpy and the pure Python version due to subtle differences in the random generator.
As explained in the \href{https://docs.python.org/3.6/library/random.html}{Python documentation}, {\em Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats
and has a period of 2**19937-1.
The underlying implementation in C is both fast and threadsafe.}
But the numpy random generator is also based on the same Mersenne Twister generator and the difference comes from the way seed is interpreted to initialize the generator.
Fortunately, Python gives access to the internal state and we can {\em fix} it to make it match the behavior of the numpy generator (which is the default).

\begin{code}{Random walk (R$^4$)}
# Random walk (R4: replicable)
# Copyright (c) 2017 Nicolas P. Rougier and Fabien C.Y. Benureau
# Release under the BSD 2-clause license
# Tested with Python 3.6 / Numpy 1.12.0 / macOS 10.12.4 / 64 bits architecture
import random
import numpy as np

def walk(rng, n):
    """ Random walk for n steps """

    steps = 2*(rng.uniform(-1,+1,n) > 0) - 1
    return steps.cumsum().tolist()

def rng(seed):
    """ Return a random number generator initialized with seed """ 
    
    rng = random.Random()
    rng.seed(seed)
    _, keys, _ = rng.getstate()
    rng = np.random.RandomState()
    state = rng.get_state()
    rng.set_state((state[0], keys[:-1], state[2], state[3], state[4]))
    return rng

if __name__ == '__main__':
    # Unit test
    assert walk(rng(seed=1), 10) == [-1, 0, 1, 0, -1, -2, -1, 0, -1, -2]

    # Actual results
    print(walk(rng(seed=2), 10))
\end{code}

\clearpage
\section*{Reusable (R$^{\mathbf 5}$)}

\begin{code}{Random walk (R$^5$)}
# Random walk (R5: re-usable)
# Copyright (c) 2017 Nicolas P. Rougier and Fabien C.Y. Benureau
# Release under the BSD 2-clause license
# Tested with Python 3.6 / Numpy 1.12.0 / macOS 10.12.4 / 64 bits architecture
import random
import numpy as np

def walk(rng, n):
    """ Random walk for n steps """

    steps = 2*(rng.uniform(-1,+1,n) > 0) - 1
    return steps.cumsum().tolist()

def rng(seed):
    """ Return a random number generator initialized with seed """ 
    
    rng = random.Random()
    rng.seed(seed)
    _, keys, _ = rng.getstate()
    rng = np.random.RandomState()
    state = rng.get_state()
    rng.set_state((state[0], keys[:-1], state[2], state[3], state[4]))
    return rng
    
if __name__ == '__main__':
    # Unit test
    # assert walk(rng(seed=1), 10) == [-1, 0, 1, 0, -1, -2, -1, 0, -1, -2]
    
    import argparse
    parser = argparse.ArgumentParser("Random walk")
    parser.add_argument('--seed', type=int, default=1,
                        help='Seed for random number generator ')
    parser.add_argument('n', type=int, default=10,
                        help='Number of step(s) to walk')
    args = parser.parse_args()

    print("Seed:", args.seed)
    print("Number of steps:", args.n)
    print("Result:",  walk(rng(args.seed), args.n))
\end{code}




\clearpage
\section*{Conclusion}

% underscore that compared to psy/bio/etc. the replication issues of CS are easily (reasonably) managed: good solutions that (mostly) works exist right now.

\renewcommand*{\bibfont}{\small}
\printbibliography[title=References]


\end{document}

